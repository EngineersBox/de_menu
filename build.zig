const std = @import("std");

// NOTE: The `dependencies` field can't be represented https://github.com/ziglang/zig/issues/22775
//       Once this merged PR https://github.com/ziglang/zig/pull/22907 has made it into a release
//       we can just bind the build.zig.zon as a module directly to allow importing
const build_zon: struct {
    name: @Type(.enum_literal),
    version: []const u8,
    fingerprint: u64,
    minimum_zig_version: []const u8,
    dependencies: struct {
        raylib_zig: struct {
            url: []const u8,
            hash: []const u8,
        },
        clap: struct {
            url: []const u8,
            hash: []const u8,
        },
        fontconfig: struct {
            path: []const u8,
            lazy: bool,
            // url: []const u8,
            // hash: []const u8,
        },
        zg: struct {
            url: []const u8,
            hash: []const u8,
        },
    },
    paths: []const []const u8,
} = @import("build.zig.zon");
const SOURCE_DIR = "src/";
const META_FILE = SOURCE_DIR ++ "meta.zig";

// For dynamic linking, we prefer dynamic linking and to search by
// mode first. Mode first will search all paths for a dynamic library
// before falling back to static.
const dynamic_link_opts: std.Build.Module.LinkSystemLibraryOptions = .{
    .preferred_link_mode = .dynamic,
    .search_strategy = .mode_first,
};

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    // const build_zon = b.createModule(.{
    //     .root_source_file = b.path("build.zig.zon"),
    //     .target = target,
    //     .optimize = optimize,
    // });
    // exe.root_module.addImport("microwave", microwave.module("microwave"));
    const host_exe_mod = b.createModule(.{
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    });
    const host_exe = create_exe(
        b,
        host_exe_mod,
        target,
        optimize,
        // build_zon,
    );
    host_exe.step.dependOn(writeMetaFileStep(b));
    b.installArtifact(host_exe);

    const run_cmd = b.addRunArtifact(host_exe);
    run_cmd.step.dependOn(b.getInstallStep());
    if (b.args) |args| {
        run_cmd.addArgs(args);
    }

    const run_step = b.step("run", "Run the app");
    run_step.dependOn(&run_cmd.step);

    const exe_unit_tests = b.addTest(.{
        .root_module = host_exe_mod,
    });
    const run_exe_unit_tests = b.addRunArtifact(exe_unit_tests);

    const test_step = b.step("test", "Run unit tests");
    test_step.dependOn(&run_exe_unit_tests.step);
}

fn writeMetaFileStep(b: *std.Build) *std.Build.Step {
    const write_version_step = b.addUpdateSourceFiles();
    const timestamp: u64 = @intCast(std.time.milliTimestamp());
    const dt = unixTimestampToUTC(timestamp);
    const file_data: []u8 = b.fmt(
        "// WARN: Autogenerated at build time, do NOT modify manually \n" ++ "pub const NAME: []const u8 = \"" ++ @tagName(build_zon.name) ++ "\";\n" ++ "pub const VERSION: []const u8 = \"" ++ build_zon.version ++ "\";\n" ++ "pub const COMPILATION_DATE: []const u8 = \"{}-{:0>2}-{:0>2}T{:0>2}:{:0>2}:{:0>2}.{:0>3}Z\";",
        .{
            dt.year,
            dt.month,
            dt.day,
            dt.hour,
            dt.minute,
            dt.second,
            dt.millisecond,
        },
    );
    write_version_step.addBytesToSource(
        file_data,
        META_FILE,
    );
    return &write_version_step.step;
}

fn create_exe(
    b: *std.Build,
    module: *std.Build.Module,
    target: std.Build.ResolvedTarget,
    optimize: std.builtin.OptimizeMode,
    // build_zon: *std.Build.Module,
) *std.Build.Step.Compile {
    // These dependencies we want to default false if we're on macOS.
    // On macOS we don't want to use system libraries because we
    // generally want a fat binary. This can be overridden with the
    // `-fsys` flag.
    for (&[_][]const u8{
        "fontconfig",
        "libpng",
        "zlib",
    }) |dep| {
        _ = b.systemIntegrationOption(
            dep,
            .{
                // If we're not on darwin we want to use whatever the
                // default is via the system package mode
                .default = if (target.result.os.tag.isDarwin()) false else null,
            },
        );
    }

    const raylib = b.dependency("raylib_zig", .{
        .target = target,
        .optimize = optimize,
        .shared = true,
        .linux_display_backend = .X11
    });
    const clap = b.dependency("clap", .{
        .target = target,
        .optimize = optimize,
    });
    _ = b.systemIntegrationOption("fontconfig", .{}); // Shows it in help
    const fontconfig = b.lazyDependency("fontconfig", .{
        .target = target,
        .optimize = optimize,
    }) orelse @panic("Missing fontconfig");

    const zg = b.dependency("zg", .{
        .target = target,
        .optimize = optimize,
    });
    const exe = b.addExecutable(.{
        .name = "de_menu",
        .root_module = module,
    });
    exe.linkLibrary(raylib.artifact("raylib"));
    // NOTE: This GitHub issue is useful for figuring
    //       out how to link stuff: https://github.com/ziglang/zig/issues/11151
    exe.root_module.addImport(
        "fontconfig",
        fontconfig.module("fontconfig"),
    );
    if (b.systemIntegrationOption("fontconfig", .{})) {
        exe.linkSystemLibrary2("fontconfig", dynamic_link_opts);
    } else {
        exe.linkLibrary(fontconfig.artifact("fontconfig"));
        _ = fontconfig.artifact("fontconfig").getEmittedBin();
    }
    // exe.root_module.addImport("build_zon", build_zon);
    exe.root_module.addImport("raylib", raylib.module("raylib"));
    exe.root_module.addImport("raygui", raylib.module("raygui"));
    exe.root_module.addImport("clap", clap.module("clap"));
    exe.root_module.addImport("zg_case_folding", zg.module("CaseFolding"));
    exe.root_module.addImport("zg_letter_casing", zg.module("LetterCasing"));
    return exe;
}

// Source: https://stackoverflow.com/a/79589141 from @frankenapps
const DateTime = struct {
    year: u32,
    month: u8,
    day: u8,
    hour: u8,
    minute: u8,
    second: u8,
    millisecond: u16,
};

fn isLeapYear(year: u32) bool {
    return (@rem(year, 4) == 0 and @rem(year, 100) != 0) or (@rem(year, 400) == 0);
}

fn daysInMonth(month: u8, year: u32) u8 {
    return switch (month) {
        1 => 31,
        2 => if (isLeapYear(year)) 29 else 28,
        3 => 31,
        4 => 30,
        5 => 31,
        6 => 30,
        7 => 31,
        8 => 31,
        9 => 30,
        10 => 31,
        11 => 30,
        12 => 31,
        else => unreachable,
    };
}

fn unixTimestampToUTC(timestamp: u64) DateTime {
    const MILLIS_PER_SEC = 1000;
    const SECS_PER_MIN = 60;
    const SECS_PER_HOUR = SECS_PER_MIN * 60;
    const SECS_PER_DAY = SECS_PER_HOUR * 24;
    const millisecond: u16 = @intCast(@rem(timestamp, MILLIS_PER_SEC));
    const seconds = @divTrunc(timestamp, MILLIS_PER_SEC);
    // Compute the time of day.
    const hour: u8 = @intCast(@divTrunc(@rem(seconds, SECS_PER_DAY), SECS_PER_HOUR));
    const minute: u8 = @intCast(@divTrunc(@rem(seconds, SECS_PER_HOUR), SECS_PER_MIN));
    const second: u8 = @intCast(@rem(seconds, SECS_PER_MIN));
    // Compute the date.
    var days = @divTrunc(seconds, SECS_PER_DAY);
    var year: u32 = 1970;
    while (true) {
        const days_in_year: u16 = if (isLeapYear(year)) 366 else 365;
        if (days >= days_in_year) {
            days -= days_in_year;
            year += 1;
        } else break;
    }
    var month: u8 = 1;
    while (true) {
        const day_of_month = daysInMonth(month, year);
        if (days >= day_of_month) {
            days -= day_of_month;
            month += 1;
        } else break;
    }
    const day: u8 = @intCast(days + 1);
    return DateTime{
        .year = year,
        .month = month,
        .day = day,
        .hour = hour,
        .minute = minute,
        .second = second,
        .millisecond = millisecond,
    };
}
